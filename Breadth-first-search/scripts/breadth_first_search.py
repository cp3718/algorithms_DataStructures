# -*- coding: utf-8 -*-
"""Breadth-first search.ipynb

Automatically generated by Colaboratory.


##1. Implement a breadth-first search algorithm.
"""

# implentation of BFS algorithm using Python

# properties
color = {} # visited dictionary
d = {} # distacne dictionary
parent = {} # parent in the bfs tree

def bfs(graph, s):
    import math

    ######## Step 1: Initializing the vertices ########

    Q = [] # queue as an empty list
    # output = [] # bfs traversal output as an empty list
    for u in graph.keys():
        if u != s:
            """ setting initial properties for all nodes excpet source node """
            color[u] = "white"
            d[u] = math.inf # infinity
            parent[u] = None

    # setting intial properties for source node
    color[s] = "gray"
    d[s] = 0
    parent[s] = None
    Q.append(s)

    while Q: # while Q is not empty
    # the truth value of the list is whether it contains an element or not
        u = Q.pop(0) # dequeue the first element in the queue
        # output.append(u)

        for v in graph[u]:
            """ changing the properties of the node as it traverses """
            if color[v] == "white":
                color[v] = "gray"
                d[v] = d[u] + 1
                parent[v] = u
                Q.append(v) # enqueue
        color[u] = "black"
    return # output

"""## 2. Determine the shortest path using results from Breadth-first search."""

def printpath(graph, s, v):
    """ function to find the shortest path
    by implementing BFS results """

    if v == s:
        print(s)
    elif parent[v] == None:
        print("No path from", s, "to", v, "exists")
    else:
        printpath(graph, s, parent[v])
        print(v)

"""## 3. Find the shortest path. Your S will be AT5G49450 and your V will be AT5G65210"""

# represting the given graph as
# an adjacency list using dictionary

adj_dict = {}
with open("large.graph", "r") as f: # opening the given graph as a file
    row = f.readlines()
    for i in row:
        g = i.strip().split("\t")
        element_1 = g[0]
        element_2 = g[-1]
        key, values = element_1, element_2
        # adj_dict[key] = values
        if key not in adj_dict:
            #storing the values of the dictionary as a list
            adj_dict[key] = list()
        adj_dict[key].append(values)

        # since the graph is bidirectional
        key, values = element_2, element_1
        if key not in adj_dict:
            adj_dict[key] = list()
        adj_dict[key].append(values)

bfs(adj_dict, 'AT5G49450')
printpath(adj_dict, 'AT5G49450', 'AT5G65210')